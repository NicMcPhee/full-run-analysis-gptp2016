%%%%%%%%%%%%%%%%%%%% author.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample root file for your "contribution" to a contributed volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% RECOMMENDED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[graybox]{svmult}

% choose options for [] as required from the list
% in the Reference Guide

\usepackage{mathptmx}       % selects Times Roman as basic font
\usepackage{helvet}         % selects Helvetica as sans-serif font
\usepackage{courier}        % selects Courier as typewriter font
\usepackage{type1cm}        % activate if the above 3 fonts are
                            % not available on your system
%
\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
                             % when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom

% see the list of further useful packages
% in the Reference Guide

% Packages I (Nic McPhee) included which may or may not cause problems.
\usepackage{todonotes}
\usepackage{rotating}

\makeindex             % used for the subject index
                       % please use the style svind.ist with
                       % your makeindex program

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title*{A detailed analysis of a PushGP run}
% Use \titlerunning{Short Title} for an abbreviated version of
% your contribution title if the original one is too long
\author{Nicholas Freitag McPhee, Mitchell D. Finzel, Maggie M. Casale, Thomas Helmuth and Lee Spector}

% Use \authorrunning{Short Title} for an abbreviated version of
% your contribution title if the original one is too long
\authorrunning{McPhee, Finzel, Casale, Helmuth, and Spector}

%\institute{Nicholas Freitag McPhee, Maggie M. Casale and Mitchell D. Finzel \at University of Minnesota, Morris; Morris, MN USA
%	\and Thomas Helmuth \at Washington and Lee University, Lexington, VA USA
%	\and Lee Spector \at Hampshire College, Amerherst, MA USA}

\institute{Nicholas Freitag McPhee \at University of Minnesota, Morris; Morris, MN USA \email{mcphee@morris.umn.edu}
\and Mitchell D. Finzel \at University of Minnesota, Morris; Morris, MN USA \email{finze008@morris.umn.edu}
\and Maggie M. Casale \at University of Minnesota, Morris; Morris, MN USA \email{casal033@morris.umn.edu}
\and Thomas Helmuth \at Washington and Lee University, Lexington, VA USA \email{helmutht@wlu.edu}
\and Lee Spector \at Hampshire College, Amerherst, MA USA \email{lspector@hampshire.edu}
}
%
% Use the package "url.sty" to avoid
% problems with special characters
% used in your e-mail or web address
%
\maketitle

% 10-15 lines is Springer's target
\todo{weak abstract}
\abstract{
	In evolutionary computation runs there is a great deal of data that could be
	saved and analyzed.
	This data is often put aside, however, in favor of focusing on the final
	outcomes, typically captured and presented in the form of summary statistics
	and performance plots.
	Here we examine a genetic programming run in detail and trace 
	back from the solution to determine how it was derived. 
	To visualize this genetic programming run, the ancestry graph is extracted, running from the 
	solution(s) in the final generation up to their ancestors in the initial random 
	population. The key instructions in the solution are also identified, and 
	a genetic ancestry graph is constructed, a subgraph of the ancestry graph
	containing only those individuals contributed genetic 
	information (or instructions) to the solution. This visualization and our
	ability to trace these key instructions throughout the run allowed us to identify general inheritance patterns and key evolutionary moments in this
	run.
}

\index{genetic programming}
\index{PushGP}
\index{ancestry graph}
\index{lineage}
\index{inheritance}

\section{Introduction}
\label{sec:introduction}

Previous work~\cite{McPhee:2015:GPTP, donatuccianalysis, Burlacu:2013:GECCOcomp:new,burlacu2015effectiveness,Burlacu:CIEES:2015,burlacu2015building, kuber2014ancestral} has
illustrated the value of ancestry graphs as a means of analyzing the dynamics
of evolutionary computation runs. In~\cite{McPhee:2015:GPTP}, for example, we
demonstrated the use of graph databases as a tool for collecting and analyzing
ancestries in genetic programming runs, identifying several key moments and
general patterns in runs using both lexicase and tournament selection.

In this paper we extend that work to provide a more detailed analysis of a
single, complete run. We identify \emph{every} ancestor of the evolved 
solutions, and
then reduce that graph (which has 394 individuals) to a graph containing only 
the individuals that in fact contributed one of the key instructions to 
the final solutions (73 individuals). We then trace each of these key solution
instructions back through the entire lineage, identifying where they were first
introduced, and how they were transmitted through the genetic history. This
reveals a number of interesting properties of this particular run including,
for example, the fact that 4 of the 9 key instructions were introduced via 
mutation and most crossover events led to changes that could have been brought about by mutation alone.

In Section~\ref{sec:background} we review the key components of the system
used to generate the run explored here (PushGP, Plush genomes, and the Replace Space With Newline test problem). We then describe and present both the full
and genetic ancestry graphs in Section~\ref{sec:ancestryGraphs}, before
tracing the evolutionary history of all the key instructions in 
Section~\ref{sec:successfulEnd}. Our discussion in 
Section~\ref{sec:discussion} builds on the details of these traces and
catalogues the kinds of events we see in this run, describing a few in greater
detail. We then wrap up with some conclusions and ideas for future work in
Section~\ref{sec:conclusions}.

\section{Tools and setup}
\label{sec:background}

\todo{Weak section title}

\todo{Talk about lexicase!}

The run presented here was generated using a Clojure implementation\footnote{Clojush: \url{https://github.com/lspector/Clojush}} of the PushGP\footnote{\url{http://pushlanguage.org/}} genetic programming system, which evolves programs in the Push programming language \cite{spector:2002:GPEM, 1068292}. Push programs use typed stacks to store and manipulate data, taking their arguments from stacks of the appropriate types and leave their results on the appropriate stacks.

Push gains much of its power as an evolutionary language from its ability to manipulate code, including the currently executing code, as a program runs. The running program is stored on the \textit{exec} stack, allowing instructions to change code before it runs. Push programs are hierarchically structured into code blocks delimited by parentheses. Each code block is treated as a single unit when code manipulating instructions act on them.

Unlike previous versions of PushGP, Clojush has recently been changed to not evolve 
Push programs directly, but to act instead on a new linear genome representation 
\cite{Helmuth:2016:GPTP}. Each \textit{Plush (\textbf{L}inear 
	\textbf{Push}) genome} consists of a linear sequence of instructions (including 
literals), and is translated into a Push program prior to execution. Each 
instruction may have one or more epigenetic markers attached that modify how 
the genome is translated into a Push program. For more details on the Plush genome
representation and operators, see~\cite{Helmuth:2016:GPTP}.
%For example, the \textit{silent} marker is a boolean that tells whether a 
%particular instruction will appear in the translated program. 

Most relevant to this study is the \textit{close} epigenetic marker, which 
affects the hierarchical composition of programs. Since many Push instructions 
do not act on code blocks from the \textit{exec} stack, it 
makes sense to limit the appearance of code blocks to follow only instructions 
that do make use of them. Each instruction that takes one or more argument from 
the \textit{exec} stack automatically opens one or more code blocks. Then, the 
integer close marker attached to each instruction tells how many opened code 
blocks to close after that particular instruction. During translation from Plush genome to 
Push program, an open parenthesis is placed after each instruction that 
requires a code block, and a matching closing parenthesis is placed after a 
later instruction with a non-zero close marker. These code blocks can create 
hierarchically nested Push programs, allowing, for example, structures such as 
nested looping and subroutines containing conditional code.

Our main crossover operator, \textit{alternation}, similar to $N$-point crossover in genetic algorithms.
Alternation traverses two parents in parallel while copying instructions from one parent or 
the other to the child. While traversing the parents, copying can jump from one parent to the other with probability specified by the \textit{alternation rate} parameter. When alternating between parents, the index at which to continue copying may be offset backward or forward some small random amount.

We also use a \textit{uniform mutation} operator that traverses a parent, 
replacing each instruction with some small probability. Similarly, a 
\textit{uniform close mutation} operator can change the close epigenetic marker 
attached to an instruction by incrementing or decrementing it. Finally, we 
often apply an alternation operator followed by a uniform mutation of the 
result, inspired by the ULTRA operator \cite{Spector:2013:GPTP}.

Push also implements a method of automatic simplification, which takes a program and 
converts it into a smaller, semantically equivalent program. This process uses 
hill-climbing to remove instructions and code blocks from the program, checking 
at each step that the resulting program produces the same error vector as the 
original program \cite{Spector:2014:GECCOcomp}. This can dramatically simplify programs, reducing, for example, one program from 194 instructions down to 9 instructions.

Our goal here is to give a deep analysis of a single run of PushGP, exploring and analyzing many of the programs, selections, and variations that make up this run. We chose to analyze a run on the Replace Space With Newline (RSWN) problem, taken from a recent general program synthesis benchmark suite \cite{Helmuth:2015:GECCO}. In this problem, a program is given a string as input and should perform two tasks: first, it must print the result of replacing each space in the input with a newline character, and second, it must functionally return the number of non-whitespace characters in the input by leaving that value on top of the \emph{integer} stack. 

To store and process our ancestry data we used the Titan graph 
database\footnote{\url{http://thinkaurelius.github.io/titan/}} along with the 
Gremlin shell and the Apache Tinkerpop\footnote{\url{https://tinkerpop.apache.org/}} query language. This 
allowed us to store information about nodes (individuals), such as genomes
and error vectors, and edges (relations) such as parent-child relationships,
along with information such as measures of the differences between parent
and child genomes. The graph database tools then make it easy to trace lineages and extract the subgraphs visualized in the next section. For these visualizations we used the
Graphviz \texttt{dot} graph layout tool
.\footnote{\url{http://www.graphviz.org/}}

%This is copied from VizGEC paper
%We use the Titan graph database\footnote{\url{http://
%thinkaurelius.github.io/titan/}} along with the Gremlin shell and the Tinkerpop query 
%tools\footnote{\url{https://tinkerpop.apache.org/}} to store the parent-child 
%relationships from genetic programming runs, and to extract the ancestry trees of 
%specified individuals. We then visualize these subgraphs using the Graphviz \texttt{dot} 
%graph layout tool.\footnote{\url{http://www.graphviz.org/}}
%\footnote{\url{http://www.graphviz.org/}}
%\subsection{THIS COPIED FROM TOM'S THESIS}

%% I (Tom) left the following in the tex in case we need more info later; most of it isn't represented above. If we use it, it shouldn't be copied directly as to not plagiarize Tom's thesis.

% Push dedicates a separate stack for each data type. Instructions take their arguments from stacks of the appropriate types and they leave their results on stacks of the appropriate types. This allows instructions and literals to be freely intermixed regardless of type while still ensuring execution safety. The convention in Push regarding instructions that are executed in contexts that provide insufficient arguments on the relevant stacks is that these instructions act as ``no-ops''; that is, they do nothing.

%Push traditionally takes results from the top items on stacks after executing a program. For example, a program that returns an integer will take the top value on the integer stack as its output. This convention means that some evolved programs might not return a value of the correct type, if the relevant stack is empty following execution; in this scenario, we penalize the program for failing to return a result. Push also has the ability to print literals to standard output; in our implementation this simply concatenates printed material to a string of whatever has been printed so far, but this could easily be changed to print to standard output.


\section{Ancestry graphs}
\label{sec:ancestryGraphs}

The run we analyze here used a population size of 1,000. 
This particular run
found a solution after 20 generations, so we stored a total of 21,000 
individuals in the graph database for this run.\footnote{We applied these tools to much larger runs, storing and analyzing relationships among millions of individuals. The level of analysis described here, however, will require considerably more automation before it can be applied to such large runs.} There were thirteen different
``winning'' individuals in that final generation, each of which had zero
error on all of the 200 training cases.

In this section we describe two techniques for extracting and 
visualizing aspects of the run. The first is the ancestry tree, which 
contains of every ancestor (e.g., parents, grandparents, etc.) of any
individual who found a solution. The second is the genetic ancestry 
tree, which is the subset of the ancestry tree limited to just those 
individuals that contributed at least one instruction to a particular
successful individual.

\subsection{Full ancestry graph}

Figure~\ref{fig:run0Labelled} shows the full ancestry tree of the 13 successful 
individuals in this run. Each individual is represented with a
rectangle containing an identifier of the form \texttt{X:Y}, where \texttt{X}
is the generation number, and \texttt{Y} is an arbitrary individual number
within that generation. Each generation is a row, with the initial random
individuals being at the top and the 13 successful individuals at the bottom.

\begin{sidewaysfigure}[tb!p] %[b] sets the image at the bottom of the page; t = top, b = bottom, h = here%
	% \sidecaption
	% Use the relevant command for your figure-insertion program
	% to insert the figure file.
	% For example, with the graphicx style use
	\begin{center}
		\vspace{0.6\columnwidth}
		\includegraphics[width=\columnwidth]{../figures/run0_GPTP_2_font_30}
	\end{center}
	\caption{The full ancestry graph containing all the ancestors of the 13
		successful individuals. Individuals are represented with boxes, with the each generation being a row; the top row in the initial random
		population, and the bottom contains the 13 successful inidividuals.
		Edges represent parent-child relationships; see the text for 
		descriptions of the meaning of the particular edge decorations.}
	\label{fig:run0Labelled}       % Give a unique label
\end{sidewaysfigure}

The edges indicate the particular genetic operator (see Section~\ref{sec:background}) used to construct a child:
\begin{itemize}
	\item Dashed: alternation
	\item Dotted: uniform mutation
	\item Thin black lines: uniform close mutation
	\item Thick black lines: alternation followed by uniform mutation
\end{itemize}

This graph includes \emph{every} individual in this run that was an 
ancestor of one of the winners, i.e., every individual that could possibly have 
contributed genetic material to one of the winners. Note, however, that not
all these individuals actually contributed any genetic material to those
solutions. There are, for example, cases where one of the parents actually
contributed no material in a recombination (alternation) event, and cases where
a parent did contribute some genetic material, but that material was later
removed or replaced in subsequent mutations or recombinations. 

Conversely, while the individuals not represented in this graph are
guaranteed to have not contributed to the genetics of the successful
individuals, they might have still had some substantial impact on the
run's overall dynamics. The presence of those individuals and their
error vectors could certainly affect lexicase selection's choice of parents,
for example, which could substantially impact the dynamics.

\subsection{Genetic ancestry graph}

Despite the short length of this run, and the restriction to just displaying
ancestors of successful individuals, Figure~\ref{fig:run0Labelled} still
contains 394 nodes and 629 edges, making it difficult to analyze in full.
Figure~\ref{fig:run0Filtered} is a version of the same graph that further
cuts down on the full ancestry tree by including only individuals who were
involved with the lineage of the key instructions in the simplified programs of the
winners.

\begin{figure}[tb!p] %[b] sets the image at the bottom of the page; t = top, b = bottom, h = here%
	% \sidecaption
	% Use the relevant command for your figure-insertion program
	% to insert the figure file.
	% For example, with the graphicx style use
	\begin{center}
		\includegraphics[height=0.95 \textheight]{../figures/filtered_fill}
	\end{center}
	\caption{The genetic ancestry version of the run's full ancestry graph.}
	\label{fig:run0Filtered}       % Give a unique label
\end{figure}

To create the genetic ancestry graph we traced the lineage of the instructions in the winners
simplified program. Starting from the winner we traced backwards through it's ancestors tracking where
the instructions came from (further explored in section 4). In doing so we found all of the members
in the full ancestry graph that contributed these important instructions and then created this genetic
ancestry graph containing only these individuals. By cutting down on the number of individuals displayed
we have a much more readable and focused visualization of some important data.

Looking at Figure~\ref{fig:run0Filtered}, it uses the same basic structure of node and edge information
as the full ancestry graph.
However there are a few key additions in how we wanted to display the additional information involving
the instructions. First off we labeled the nodes with which instructions are present, unlabeled nodes
have the same instructions as the nearest labeled ancestor. Next we added a dark border to 
nodes, to further indicate the addition of a key instruction via either mutation or crossover. Lastly
we used a grayscale color gradient to help track the instructions. An example of this coloration can be seen
in 3:122 and its children. 3:122 has a gradient of three shades of gray that represent its three instructions.
Its children are given a shade of gray based on which of those instructions they received. As the grays
are added into individuals with more and more instructions the grays are blended.

For the edges we added the Damerau-Levenshtein distance (DL-distance)
between genome vectors for each parent-child pair; these distances
are indicated as edge labels in Figure~\ref{fig:run0Filtered}. The genome
vectors were generated by extracting the \texttt{:instruction} and 
\texttt{:close} fields from each gene, and concatenating those into a
single sequence. So, for example, the genome of successful individual
20:435 starts

%\todo{Should this prefix of the genome be in a figure so it doesn't get broken up by things like page breaks?}
\begin{verbatim}
{:instruction boolean_and, :close 0} 
{:instruction boolean_shove, :close 0} 
{:instruction exec_do*count, :close 0} 
{:instruction exec_swap, :close 0} 
{:instruction integer_empty, :close 0}
...
\end{verbatim}

making the associated genome vector

\begin{verbatim}
boolean_and 0 boolean_shove 0 exec_do*count 0 
exec_swap 0 integer_empty 0 ...
\end{verbatim}

The Damerau-Levenshtein distance provides a succinct way to see when an individual has received a
large amount of genetic material from its parents. It also allows us to easily identify alternation
events that have mutation like behavior with small changes to genome.

\section{The (successful) end and how we get there}
\label{sec:successfulEnd}

There are 13 successful individuals
in this run, most of which have identical simplified
programs. In the interest of space we're going to focus on one of those, 
individual 20:435, which was constructed via three instruction mutations
from individual 19:554.
Individual 20:435's genome contains 194 genes and has zero error on both
the training and testing cases.
The simplified program for 20:435 (which also passes all the tests)
contains only 9 instructions:
\begin{verbatim}
(\space \newline in1 string_replacechar print_string
in1 \space string_removechar string_length)
\end{verbatim}
This simplified program is actually quite readable, and has a similar
structure to what me might expect from a human solution.
The first five 
instructions (together on the first line) replace all the spaces in the input string 
with newlines (using the \texttt{string\_replacechar} instruction) and print the 
resulting string, thereby solving half the problem. 
The next four instructions (on the second line) remove all the spaces from
a fresh copy of the input string, compute the length and leave that on the
\texttt{:integer} stack as the ``returned'' result.

\subsection{How did we get there?}
\label{sec:howDidWeGetThere}

In this section we will trace the origin of each of the nine instructions
in the simplified program for individual 20:435,
going back to their introduction either via a mutation or as an element 
of one of the initial, random programs in the initial generation. It's clear
that each of these was ``necessary'' for the construction of this particular
solution, so knowing where they all came from and how they came together
should give us a valuable sense of the dynamics of this run. 

It's important to realize, however, that this will
never be the whole story. Push instructions and values can play an 
important role in subtle ways, e.g., as spacers on stacks that when
``counting'' is implemented with a stack depth command. Removal of
instructions can also be important. One key step in this run, for example, 
is the removal of an extraneous \texttt{print\_newline}; the presence of this
instruction caused the printed output to always have an error of one,
and its removal led to 100 errors changing
from 1 to 0. All that said, however, we need some way to limit the number
of individuals and events to analyze, so here will focus on the how those
nine instructions trace through the ancestry.

It's also important to note that we didn't actually collect enough information
to \emph{always} say for certain where an instruction came from in a 
recombination event. There are numerous copies of instructions like
\texttt{in1} in most of the genomes, for example, and in principle any of them
in a parent could be the source of an \texttt{in1} in the child. In practice,
however, there are constrains of location and order that typically allowed
us to identify a single, unique source. There were a few places, however, where
judgement calls were made. In future work we're going to explore attaching
unique IDs to each gene and track not just parent-child relationships, but
also source-destination relationships among genes, as this will give us
certainty about the sources of genes, and allow us to automate more of the
analysis, all at the expense of larger databases.

Returning to the specific program from Section~\ref{sec:successfulEnd},
it turns
out that the evolution of the first five instructions, those handling the
printing part of Replace Space With Newline, is largely independent of
the evolution of the last four instructions, which handle the return part
of the problem. The first five instructions, for example, all appear early 
in the genome for 20:435, from gene 9 to gene 24, while the last four 
all appear much later in the genome, from gene 107 to gene 175. As a consequence
we'll trace these two groups one at a time.

\subsection{Printing: The first five instructions}
\label{sec:Printing}

What is witnessed in the ancestry of the 5 instructions key to solving the printing test
cases (even cases) is fairly interesting and straightforward. Starting at the top with individual 0:288 only
one of the key instructions, \texttt{in1}, is present. The rest of the 5 are introduced over time purely
through uniform mutations. The next of the key instructions to appear is introduced in individual 1:590 via a point
mutation converting a piece of 0:288's genome into a \texttt{print\_string} instruction. These two
instructions are passed along this branch until they are joined by the next important instruction,
\texttt{\textbackslash newline}. This instruction is introduced in 7:788 via uniform mutation
of 6:881.

After descending another 2 generations these three instructions were joined by \texttt{string\_replacechar}
in 9:896 via yet another uniform mutation. At this point it's interesting to note that these instructions are
all introduced fairly evenly over the course of these generations. Even as the run gets closer to the generation
20 winners these individuals obtained key instructions through random uniform mutations. Which lead to
the final of these key instructions being introduced, \texttt{\textbackslash space}.
This instruction is added in generation 14 via a uniform mutation of 13:580 into 14:704, thus completing the five key printing
instructions that are passed down through 15:801 and maintained all of the way down to the winners.

This marks another interesting point about these instructions. Unlike the return case instructions there is a clear path of lineage for these instructions. As they are introduced over time they 
are never split apart into branches to be recombined later. Rather they were added via mutation and 
then passed down together consistently from 0:288 down to the winners.

These instruction additions can also be seen affecting the error vectors in their individuals. Each instruction that is addition
is accompanied by a shift in the even test cases. Sometimes effect is minimal with both positive and negative changes
in the test cases. Other times the change is larger and causes dramatic improvement. An example of a small change is when
\texttt{print\_string} was mutated into 1:590. This mutation causes 83 of the 100 even test cases to generally improve except for a few individuals that worsen.
Meanwhile in the mutation of 13:580  in the creation of 14:704 we saw all of the even test scores become 1. This is in general a very
big improvement, but worsened a few tests that had passed with no error in 13:580. These examples help to highlight
and support the value of these instructions as each step we saw a change, often for the better. This is not to
say that steps where these instructions are not added haven't had changes in their error vectors, but shines light
on how it is necessary to both find the right instructions as well as remove instructions that hinder the solution.

\subsection{Returning: The last four instructions}
\label{sec:Returning}

These last four instructions were present in the right order and in at least
rough proximity in the very first generation, in individual 0:126. The first of these instructions (\texttt{in1}) was on gene 75 of the genome, the next two
(\texttt{\textbackslash space} and \texttt{string\_removechar}) were on 
genes 89 and 94, and then the final instruction (\texttt{string\_length}) 
was on line 141 (out of a total of 161 genes in the genome).

Despite the fact that this individual had ``all the right stuff'', it's error
vector had very few zeros, i.e., it was rarely correct, highlighting
the fact that the presence or absence of other instructions can profoundly
impact a program's behavior. 0:126 was, however, quite good for a randomly
generated program, with all it's errors being under 20, and most being in
the single digits. It was selected 45 times to be a parent, making it the
seventh most selected parent in the initial generation, and one of only 48
individuals in the initial generation that received any selections. 
(The most selected
parent in that generation, 0:272, was selected 762 times, but ultimately
contributed no genes to the winning individual and therefore is not shown in the graph.)

Those four instructions were passed on as a group, with nearly the same 
relative positions in the genomes, from 0:126 through 1:783 and 2:983 
to 3:122 (see Figure~\ref{fig:run0Filtered}). 
3:122 was the third most selected individual in its generation
and had 100 children, several of which went on to carry one or more of
these four instructions forward to individual 19:554 when they were finally
reunited in the positions that would ultimately lead to success. In particular
there were three distinct branches coming from 3:122, each of which will
be discussed in this subsection.

\subsubsection{Branch 4:772 and the carriers of \texttt{in1}}
\label{sec:4:772}

Individual 4:772 inherited the copy of the first instruction,
\texttt{in1}, that would ultimately form part of the solution. This was
transmitted down to 9:109 without the other 8 out of 9  ``final'' instructions. Individual 9:109, however, recombined with 
9:896 which, as mentioned above in Section~\ref{sec:Printing}, carried
all but one of the first five ``printing'' instructions. 

This recombination
led to individual 10:473, which then had 4 of the 5 ``printing'' instructions,
as well as the \texttt{in1} that would be the first of the 4 ``returning''
instructions. These five instructions were then passed down to 14:704, 
along with the 
\texttt{\textbackslash space} introduced by mutation in 14:704. 14:704 was
one of the parents of 15:801, a recombination which will be described in the
discussion of the next branch.

\subsubsection{Branches 4:425, 4:107, and multiple blocks}
\label{sec:4:425}

3:122 contained a block of 25 genes % genes 77 to 101
that contain the two middle instructions in the ``returning''
code, \texttt{\textbackslash space} and \texttt{string\_removechar}.
This block is replicated in both 4:425 and 4:107, and then passed,
respectively, to 5:303 and 5:910. 5:303 and 5:910 then recombine
to create 6:293, which ends up having two complete copies of this
block of genes. % genes 67 to 91 and 100 to 124.

These two blocks are then replicated from 7:291 down through 10:41,
to both 13:136 and 13:575. When these recombined to form 14:213
we ended up with \emph{three} near copies of the block. These blocks
are no longer identical due to small changes caused by the
genetic operators, but each block still contained over 20 genes,
including the two key instructions,
\texttt{\textbackslash space} and \texttt{string\_removechar},
four instructions apart.

All three of these blocks (and their three copies of these two ``final''
instructions) are passed on to 15:801 in the recombination of 14:213 and
14:704. 14:704 also bequeathed to 15:801 all of its six ``final'' 
instructions, meaning that 15:801 has all but the last of the 9 ``final''
instructions (\texttt{string\_length}).

\subsubsection{Branch 4:897 and the carriers of \texttt{string\_length}}
\label{sec:4:897}

4:897 and its descendants carried the copy of the last instruction, 
\texttt{string\_length}, that would ultimately form part of the solution. 
This was transmitted all the way down to
18:641 without any significant interactions with other ``final instructions'',
as is reflected in the almost entirely linear ancestry from 4:897 to 18:641 
in Figure~\ref{fig:run0Filtered}.

There is one potentially interesting interaction with the other branches, 
when 15:543 combined with 15:801 to create 16:964. It turned out
that 15:801 did not contribute genetic information that led to the solution found. 15:543 held the crucial missing \texttt{string\_length} gene that had been passed down since our starting random generation. Essentially, 16:964 was made through alternation and uniform mutation so 15:543 combined with 15:801. The only substantial gene that 16:964 contributed to the solution was \texttt{string\_length} from 15:543.

\subsection{From 19:554 to the end and the final adjustments}

19:554 was the result of a recombination of 18:641 and 18:937, which finally
brought together all nine of the ``final'' instructions. 18:937 contributed
the first 8 instructions, and 18:641 contributed the final 
\texttt{string\_length} instruction. Individual 19:554 didn't \emph{quite} solve the
problem, it did have three ``return'' test cases with error 1. These three test cases turned out to be the only cases with an input of a single character.

These errors were fairly easy to rectify, however, as evidenced by the 
fact that 12 of 19:554's 747 offspring (or 1.6\%) were indeed successful.
Two of these successful children (20:435 and 20:548) were the result of 
mutating a \emph{single} instruction. The mutation that led to 20:435 
caused the instruction \texttt{string\_butlast} to not operate. \texttt{string\_butlast} was incorrectly removing the one and only character
from the input string. So the mutation of the instruction led to a perfect solution.

\section{Discussion}
\label{sec:discussion}

The trace in Section~\ref{sec:howDidWeGetThere} provides a sense of where all
the key instructions came from, and indicates several of the key moments in the
evolutionary process. In this section we'll provide some summary information
as well as highlighting both some general patterns and a few important events.

Table~\ref{tab:operatorCounts} enumerates the number and proportions 
of individuals constructed via the four genetic operators, first across the
entire run (so all of the 20,000 individuals generated after the initial
random population), then for the ancestry graph in 
Figure~\ref{fig:run0Labelled} (394 total nodes, 
376 constructed after the initial generation), and finally for the genetic 
ancestry
graph in Figure~\ref{fig:run0Filtered} (62 total nodes, 60 constructed after 
the initial generation). The percentages in the ``Entire run'' column match
the settings in the run configuration, which specified using alternation 
followed by uniform mutation 50\% of the time, alternation alone 20\% of the 
time, uniform mutation 20\% of the time, and uniform close mutation the 
remaining 10\% of the time. 
The other two columns have similar percentages,
suggesting that there wasn't a large skew away from those parameter values
and that none of the genetic operators were particularly over- or 
under-represented in the ancestry graphs.

\begin{table}[t]
	\begin{tabular}{lrrr}
		\textbf{Genetic operator} & \textbf{Entire run} & $\;$ \textbf{Full ancestry graph} & $\;$ \textbf{Genetic ancestry graph} \\ 
		\hline
		Alternation + uniform mutation & 9,985 (50\%) & 186 (49\%) & 39 (54\%) \\ 
		Alternation & 4,001 (20\%) & 67 (18\%) & 17 (24\%) \\ 
		Uniform mutation & 4,026 (20\%) & 83 (22\%) & 11 (15\%) \\ 
		Uniform close mutation & 1,988 (10\%) & 40 (11\%) & 5 (7\%)
	\end{tabular} 
	\caption{The numbers and proportions of individuals constructed using
		the different genetic operators. Total percentages might not equal 100\% due to rounding.}
	\label{tab:operatorCounts}
\end{table}

While there are numerous alternations in the genetic ancestry graph, it's worth
noting that many of the DL-distances (the edge labels in 
Figure~\ref{fig:run0Filtered}) are fairly small, even when alternation was
involved, as can be seen in Figure~\ref{fig:alt:DLdist:distribution}. Of the
53 alternations (ignoring those leading to a successful individual in 
generation 20), 21 had DL-distances of 10 or less, 6 had DL-distances of just 1,
and 5 had DL-distances of 0 (the child was an exact copy of the parent).
One might assume that this is partly due to the six 
self-cross alternations, where the same individual served as both parents, 
such as individual 16:106 having 15:801 as both of its parents.\footnote{Most of these self-crosses are likely a result of hyperselection events due to lexicase 
	selection~\cite{Helmuth:2016:GECCO}.} In fact, however, most of the 
self-crosses in the genetic ancestry graph had higher than median DL-distances.

\begin{figure}[t]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{../figures/Alternation_dl_distance_distribution}
	\end{center}
	\vspace{-0.5 cm}
	\caption{The distribution of DL-distances for all the alternation events, 
		in the genetic ancestry graph (Figure~\ref{fig:run0Filtered}) whether 
		or not they were followed by uniform mutation. This does not include
		the alternations leading to successful individuals in the final \
		generation since those were mostly self-crosses, which skew towards 
		smaller DL-distances.}
	\label{fig:alt:DLdist:distribution}
\end{figure}

These very small DL-distances mean that many of the alternations were 
effectively acting as mutation events, either through a small number of
mutations following an alternation that didn't change the parent, or 
through small deletions or replications of code. The steps from individual
15:801 to 18:937, for example, are all alternations (possibly followed
by mutations), but in fact almost every change in that sequence was due to
gene deletions or duplications in those alternation events. There were 3
mutated genes in that sequence of steps, along with 12 deleted genes and the
duplication of a block of 7 genes.

Since the genetic ancestry graph (and thus the data in 
Figure~\ref{fig:alt:DLdist:distribution}) only includes individuals that 
actually
contributed one of the nine key instructions, in many cases the second parent
in alternation events isn't included; these DL-distances are in general
higher than those listed. This isn't surprising, as a parent with a small
DL-distance is very similar to the child, and thus likely to have contributed
most of the important genetic material. There are, however, a few exceptions 
to this pattern. Perhaps the most extreme is in the creation of individual
3:273 via alternation between 2:659 and 2:779. Individual 2:659 is not included
in the genetic ancestry graph in Figure~\ref{fig:run0Filtered} because it didn't
contribute any of the nine key instructions to 3:273, whereas 2:779 contributed
two such instructions. However the DL-distance between 3:273 and 2:779 was 457, 
which was much greater than the distance to 2:659, which was only 50. So despite
being much more similar to 2:659 and getting most of its genetic material from
that parent, the material that ultimately contributed to the solution all came
from the other parent (2:779).

Not all alternation events in Figure~\ref{fig:run0Filtered} could effectively be seen as
mutation events, however. The construction of 15:801, for example,
was in many ways what we imagine when we talk about
crossover events, combining significant genetic material and significant functionality from two different parents. It was also a key point in the run,
as 15:801 was the first individual to be correct on all of the ``printing''
test cases, and it was also correct on 26 of the 100 ``returning'' test cases.

Individual 15:801 was created through the recombination of 14:704 and 14:213,
via alternation followed by uniform mutation. 
Table~\ref{tab:15:801} shows the simplified programs of 
both parents and the child,
aligned to indicate where the various instructions likely came from. The key
observation is that 15:801 received most of its initial genetic material from 
14:704 (most of genes 1-6), followed by a large section (genes 7-35) taken
almost entirely from 14:213's genome. Interestingly, the transition between 14:704 and 15:801 involved a simple but crucial change that fixed all the
printing cases. 14:704 had an error of exactly 1 on all the printing cases
due to an extra \texttt{print\_newline} (line 37 in Table~\ref{tab:15:801}).
In the recombination this gene wasn't passed on to 15:801, which led to a
perfect score of 0 on all those test cases. The performance of 15:801 on
the return test cases wasn't quite as strong as that of its other parent,
14:213, but was generally better than 14:704's performance on those test cases. This led to 15:801 receiving a large number of selections (595) and being
a parent of just over half the population (501 individuals).

\begin{table}
	\begin{tabular}{l|rl|l}
		\textbf{14:704} & & \textbf{15:801} & \textbf{14:213} \\
		\hline
		& 0 & & \texttt{(in1} \\ 
		\texttt{(\textbackslash space} & 1 & \texttt{(\textbackslash space} & \\ 
		\texttt{ \textbackslash newline} & 2 & \texttt{ \textbackslash newline} &  \\ 
		& 3 & \texttt{ exec\_dup} &  \\ 
		\texttt{ in1} & 4 & \texttt{ in1} &  \\ 
		\texttt{ string\_replacechar} & 5 & \texttt{ string\_replacechar} &  \\ 
		\texttt{ print\_string} & 6 & \texttt{ print\_string} & \texttt{ print\_string} \\ 
		& 7 & \texttt{ exec\_dup} & \texttt{ exec\_dup} \\ 
		& 8 &  & \texttt{ exec\_s} \\ 
		& 9 &  & \texttt{ (exec\_dup} \\ 
		& 10 &  & \texttt{ \ (exec\_rot} \\ 
		& 11 & \texttt{ (string\_eq} & \texttt{ \ \ (string\_eq} \\
		& 12 & &  \texttt{ \ \ \ string\_fromboolean)} \\ 
		& 13 &  & \texttt{ \ \ char\_eq} \\ 
		& 14 & & \texttt{ \ \ (string\_emptystring} \\
		& 15 & &  \texttt{ \ \ \ boolean\_stackdepth} \\
		& 16 & & \texttt{ \ \ \ in1} \\
		& 17 & & \texttt{ \ \ \ integer\_gt)} \\ 
		& 18 &  & \texttt{ \ \ string\_emptystring} \\ 
		& 19 & \texttt{ \ \textbackslash space} & \texttt{ \ \ \textbackslash space} \\ 
		& 20 & \texttt{ \ string\_dup} & \texttt{ \ \ string\_dup} \\ 
		& 21 & \texttt{ \ string\_removechar} & \texttt{ \ \ string\_removechar} \\
		& 22 & \texttt{ \ string\_rot} & \\
		& 23 & & \texttt{ \ \ boolean\_pop} \\ 
		& 24 &   & \texttt{ \ \ in1} \\ 
		& 25 &   & \texttt{ \ \ string\_butlast} \\ 
		& 26 &   & \texttt{ \ \ string\_last} \\ 
		& 27 &   & \texttt{ \ \ string\_parse\_to\_chars} \\
		& 28 &   & \texttt{ \ \ exec\_when} \\ 
		& 29 &   & \texttt{ \ \ string\_dup} \\
		& 30 &   & \texttt{ \ \ string\_removechar} \\
		& 31 & \texttt{ \ string\_last} & \texttt{ \ \ string\_last} \\
		& 32 & \texttt{ \ string\_parse\_to\_chars} & \texttt{ \ \ string\_parse\_to\_chars} \\
		& 33 & \texttt{ \ string\_rot)} & \texttt{ \ \ string\_rot)} \\
		& 34 & \texttt{ in1} & \texttt{ \ in1)} \\
		& 35 & \texttt{ string\_stackdepth)} & \texttt{ string\_stackdepth)} \\
		\texttt{ boolean\_stackdepth} & 36 & & \\
		\texttt{ print\_newline)} & 37 & & \\
	\end{tabular}
	\caption{The details of the recombination event (alternation followed by
		uniform mutation) that created individual
		15:801 (center) from parents 14:704 (left) and 14:213 (right) showing
		the \emph{simplified} programs for those individuals (see
		Section~\ref{sec:background}). This shows that individual 15:801 was
		essentially constructed from a prefix of 14:704 and a suffix of 14:213.}
	\label{tab:15:801}
\end{table}

\section{Conclusions and future work}
\label{sec:conclusions}

Here we have traced through the genetic ancestry of a short, successful genetic programming run. While the run was short, it used an ``industrial strength''
PushGP system\footnote{\url{https://github.com/lspector/Clojush}} on a
non-trivial problem that required the manipulation of strings in multiple
ways, and a combination of both printing and returning results. We used graph
database tools to create
ancestry and genetic ancestry graphs, which we were then able to use to 
visualize and analyze this run. The resulting graphs
show the progression of the run and highlight important moments such as key
recombination events, gene deletions and duplications, and the introduction
of key instructions via mutation. By tracing through the genetic ancestry tree we were able to learn more about how both alternation and mutation played a role in finding a solution.

While we were able to do this for a small run, currently too much of the
process is manual for this to scale to larger runs or multiple sets of runs.
A key next step in further automating this kind of analysis is automating the 
process of comparing individuals, especially at the genome level. Tracing
each key instruction back through the ancestry graph can be complicated, in
part because there are often many different instances of the instruction being traced; individual 19:554, for example, had four instances of 
\texttt{\textbackslash space}, but only three of those were present in its
simplified program, and only two went on to be part of the simplified
successful program in 20:435. In this case we were able to deal with these
problems by using contextual clues such as order in the genome and surrounding
instructions, not unlike how biologists track gene sequences in organisms.
To make this process more automatic, however, we'll need to save additional
information with the individual genes that allows us to know exactly where they 
came from.

It would also be valuable to improve our ability to understand and compare
program behaviors. While we can easily compare genomes and error vectors,
and reasonably compare program \emph{texts}, comparing program \emph{behaviors}
is much less straightforward. While the simplified program for individual
20:435 is quite short and understandable, the unsimplified program contains
195 instructions, which include a number of complex looping constructs. These
are obviously not necessary for the semantics of the program, but they are
present in the code that is being tested, and the genes that create those
instructions are part of the genome that is being manipulated and inherited.
And while those instructions might be removable from 20:435 at the end 
of the run, it's likely that many of those instructions played some
meaningful role in an ancestor that contributed to that ancestor's selection.

Lastly, and more simply, the prevalence of numerous alternation events in the 
gene ancestry graph that turned out to be just gene deletions or duplications 
suggests that it might be valuable to include deletion and replication 
mutations as stand-alone operators, instead of requiring that such events
occur via lucky alternations.

\begin{acknowledgement}
	Emma Sax, Laverne Schrock, and Leonid Scott helped 
	with the initial computation and analyses of the differences between the 
	parents and children discussed here. William Tozier provided a host of 
	ideas and feedback all through the process, as did numerous members
	of the Hampshire College Computational Intelligence lab.
	
	This material is based upon work supported by the National Science Foundation under Grants No. 1129139 and 1331283. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the National Science Foundation.
\end{acknowledgement}

\bibliographystyle{spmpsci}
\bibliography{gp-bibliography,mcphee}

%\section{Section Heading}
%\label{sec:1}
%Use the template \emph{chapter.tex} together with the Springer document class SVMono (monograph-type books) or SVMult (edited books) to style the various elements of your chapter content in the Springer layout.
%
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations. And please note that the first line of
%text that follows a heading is not indented, whereas the first lines of
%all subsequent paragraphs are.
%
%\section{Section Heading}
%\label{sec:2}
%% Always give a unique label
%% and use \ref{<label>} for cross-references
%% and \cite{<label>} for bibliographic references
%% use \sectionmark{}
%% to alter or adjust the section heading in the running head
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations.
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%Use the standard \verb|equation| environment to typeset your equations, e.g.
%%
%\begin{equation}
%a \times b = c\;,
%\end{equation}
%%
%however, for multiline equations we recommend to use the \verb|eqnarray| environment\footnote{In physics texts please activate the class option \texttt{vecphys} to depict your vectors in \textbf{\itshape boldface-italic} type - as is customary for a wide range of physical subjects}.
%\begin{eqnarray}
%a \times b = c \nonumber\\
%\vec{a} \cdot \vec{b}=\vec{c}
%\label{eq:01}
%\end{eqnarray}
%
%\subsection{Subsection Heading}
%\label{subsec:2}
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references\index{cross-references} and citations\index{citations}
%as has already been described in Sect.~\ref{sec:2}.
%
%\begin{quotation}
%Please do not use quotation marks when quoting texts! Simply use the \verb|quotation| environment -- it will automatically render Springer's preferred layout.
%\end{quotation}
%
%
%\subsubsection{Subsubsection Heading}
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations as has already been described in
%Sect.~\ref{subsec:2}, see also Fig.~\ref{fig:1}\footnote{If you copy
%text passages, figures, or tables from other works, you must obtain
%\textit{permission} from the copyright holder (usually the original
%publisher). Please enclose the signed permission with the manuscript. The
%sources\index{permission to print} must be acknowledged either in the
%captions, as footnotes or in a separate section of the book.}
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%% For figures use
%%
%\begin{figure}[b]
%\sidecaption
%% Use the relevant command for your figure-insertion program
%% to insert the figure file.
%% For example, with the graphicx style use
%\includegraphics[scale=.65]{figure}
%%
%% If no graphics program available, insert a blank space i.e. use
%%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%%
%\caption{If the width of the figure is less than 7.8 cm use the \texttt{sidecapion} command to flush the caption on the left side of the page. If the figure is positioned at the top of the page, align the sidecaption with the top of the figure -- to achieve this you simply need to use the optional argument \texttt{[t]} with the \texttt{sidecaption} command}
%\label{fig:1}       % Give a unique label
%\end{figure}
%
%
%\paragraph{Paragraph Heading} %
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations as has already been described in
%Sect.~\ref{sec:2}.
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%For typesetting numbered lists we recommend to use the \verb|enumerate| environment -- it will automatically render Springer's preferred layout.
%
%\begin{enumerate}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\begin{enumerate}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\end{enumerate}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\end{enumerate}
%
%
%\subparagraph{Subparagraph Heading} In order to avoid simply listing headings of different levels we recommend to let every heading be followed by at least a short passage of text. Use the \LaTeX\ automatism for all your cross-references and citations as has already been described in Sect.~\ref{sec:2}, see also Fig.~\ref{fig:2}.
%
%For unnumbered list we recommend to use the \verb|itemize| environment -- it will automatically render Springer's preferred layout.
%
%\begin{itemize}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development, cf. Table~\ref{tab:1}.}
%\begin{itemize}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\end{itemize}
%\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
%\end{itemize}
%
%\begin{figure}[t]
%\sidecaption[t]
%% Use the relevant command for your figure-insertion program
%% to insert the figure file.
%% For example, with the option graphics use
%\includegraphics[scale=.65]{figure}
%%
%% If no graphics program available, insert a blank space i.e. use
%%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%%
%%\caption{Please write your figure caption here}
%\caption{If the width of the figure is less than 7.8 cm use the \texttt{sidecapion} command to flush the caption on the left side of the page. If the figure is positioned at the top of the page, align the sidecaption with the top of the figure -- to achieve this you simply need to use the optional argument \texttt{[t]} with the \texttt{sidecaption} command}
%\label{fig:2}       % Give a unique label
%\end{figure}
%
%\runinhead{Run-in Heading Boldface Version} Use the \LaTeX\ automatism for all your cross-references and citations as has already been described in Sect.~\ref{sec:2}.
%
%\subruninhead{Run-in Heading Italic Version} Use the \LaTeX\ automatism for all your cross-refer\-ences and citations as has already been described in Sect.~\ref{sec:2}\index{paragraph}.
%% Use the \index{} command to code your index words
%%
%% For tables use
%%
%\begin{table}
%\caption{Please write your table caption here}
%\label{tab:1}       % Give a unique label
%%
%% Follow this input for your own table layout
%%
%\begin{tabular}{p{2cm}p{2.4cm}p{2cm}p{4.9cm}}
%\hline\noalign{\smallskip}
%Classes & Subclass & Length & Action Mechanism  \\
%\noalign{\smallskip}\svhline\noalign{\smallskip}
%Translation & mRNA$^a$  & 22 (19--25) & Translation repression, mRNA cleavage\\
%Translation & mRNA cleavage & 21 & mRNA cleavage\\
%Translation & mRNA  & 21--22 & mRNA cleavage\\
%Translation & mRNA  & 24--26 & Histone and DNA Modification\\
%\noalign{\smallskip}\hline\noalign{\smallskip}
%\end{tabular}
%$^a$ Table foot note (with superscript)
%\end{table}
%%
%\section{Section Heading}
%\label{sec:3}
%% Always give a unique label
%% and use \ref{<label>} for cross-references
%% and \cite{<label>} for bibliographic references
%% use \sectionmark{}
%% to alter or adjust the section heading in the running head
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations as has already been described in
%Sect.~\ref{sec:2}.
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%If you want to list definitions or the like we recommend to use the Springer-enhanced \verb|description| environment -- it will automatically render Springer's preferred layout.
%
%\begin{description}[Type 1]
%\item[Type 1]{That addresses central themes pertainng to migration, health, and disease. In Sect.~\ref{sec:1}, Wilson discusses the role of human migration in infectious disease distributions and patterns.}
%\item[Type 2]{That addresses central themes pertainng to migration, health, and disease. In Sect.~\ref{subsec:2}, Wilson discusses the role of human migration in infectious disease distributions and patterns.}
%\end{description}
%
%\subsection{Subsection Heading} %
%In order to avoid simply listing headings of different levels we recommend to let every heading be followed by at least a short passage of text. Use the \LaTeX\ automatism for all your cross-references and citations citations as has already been described in Sect.~\ref{sec:2}.
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%\begin{svgraybox}
%If you want to emphasize complete paragraphs of texts we recommend to use the newly defined Springer class option \verb|graybox| and the newly defined environment \verb|svgraybox|. This will produce a 15 percent screened box 'behind' your text.
%
%If you want to emphasize complete paragraphs of texts we recommend to use the newly defined Springer class option and environment \verb|svgraybox|. This will produce a 15 percent screened box 'behind' your text.
%\end{svgraybox}
%
%
%\subsubsection{Subsubsection Heading}
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations as has already been described in
%Sect.~\ref{sec:2}.
%
%Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
%\begin{theorem}
%Theorem text goes here.
%\end{theorem}
%%
%% or
%%
%\begin{definition}
%Definition text goes here.
%\end{definition}
%
%\begin{proof}
%%\smartqed
%Proof text goes here.
%\qed
%\end{proof}
%
%\paragraph{Paragraph Heading} %
%Instead of simply listing headings of different levels we recommend to
%let every heading be followed by at least a short passage of text.
%Further on please use the \LaTeX\ automatism for all your
%cross-references and citations as has already been described in
%Sect.~\ref{sec:2}.
%
%Note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%%
%% For built-in environments use
%%
%\begin{theorem}
%Theorem text goes here.
%\end{theorem}
%%
%\begin{definition}
%Definition text goes here.
%\end{definition}
%%
%\begin{proof}
%\smartqed
%Proof text goes here.
%\qed
%\end{proof}
%%
%\begin{acknowledgement}
%If you want to include acknowledgments of assistance and the like at the end of an individual chapter please use the \verb|acknowledgement| environment -- it will automatically render Springer's preferred layout.
%\end{acknowledgement}
%%
%\section*{Appendix}
%\addcontentsline{toc}{section}{Appendix}
%%
%%
%When placed at the end of a chapter or contribution (as opposed to at the end of the book), the numbering of tables, figures, and equations in the appendix section continues on from that in the main text. Hence please \textit{do not} use the \verb|appendix| command when writing an appendix at the end of your chapter or contribution. If there is only one the appendix is designated ``Appendix'', or ``Appendix 1'', or ``Appendix 2'', etc. if there is more than one.
%
%\begin{equation}
%a \times b = c
%\end{equation}

\end{document}
